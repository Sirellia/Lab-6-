#Сумма в правом верхней подматрице должна быть наибольшая и произведение на главной диагонали наибольшая
#Выводится лучшая матрица где сумма произведения на главной диагонали и сумма наибольшая
import numpy as np

matrix = [
    [1, 2,3,4],
    [5,6,7,8],
    [9,10,11,12],
    [13,14,15,16]
]

sub_matrices = []
n = len(matrix) // 2

for i in range(2):
    for j in range(2):
        sub_matrices.append([row[j * n:(j + 1) * n] for row in matrix[i * n:(i + 1) * n]])

combinations = []
for i in range(4):
    for j in range(4):
        if j == i:
            continue
        for k in range(4):
            if k == i or k == j:
                continue
            l = 6 - i - j - k
            combinations.append([sub_matrices[i], sub_matrices[j], sub_matrices[k], sub_matrices[l]])


def objective_function(matrix):
    diagonal_elements = [matrix[i][i] for i in range(len(matrix))]
    return np.prod(diagonal_elements)


def upper_right_sum(matrix):
    rows, cols = matrix.shape
    upper_right = matrix[:rows//2, cols//2:]
    return np.sum(upper_right)


best_combination = None
best_score = float('-inf')

for c in combinations:
    new_matrix = []
    for j in range(n * 2):
        if j < n:
            new_matrix.append(c[0][j] + c[1][j])
        else:
            new_matrix.append(c[2][j - n] + c[3][j - n])

    score = objective_function(new_matrix) + upper_right_sum(np.array(new_matrix))

    if score > best_score:
        best_score = score
        best_combination = new_matrix

print("Лучшая комбинация матриц:")
for row in best_combination:
    print(row)
print("Произведение элементов на главной диагонали + Сумма в правом верхнем квадранте:", best_score)



